---
title: "FA1_AFUNDAR_DATAMINING"
author: "Audrie Lex L. Afundar"
date: "2025-02-02"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r, include=FALSE}
library(tidyverse)
library(ggplot2)
library(ggcorrplot)
data(heights)
```
## Lecture 2

Call Diamonds and create a bar chart

## Bar chart

```{r}
diamonds
## barchart
ggplot(data=diamonds)+
  geom_bar(mapping=aes(x=cut))

```
The bar chart shows the count of each types of cut, highest being of ideal.


## Histogram 

```{r}
ggplot(data=diamonds)+
  geom_histogram(mapping=aes(x=carat),binwidth=0.1)
```

Histogram zoomed to 0-3 since there are little to no input in 4-5
```{r}
ggplot(data = diamonds) + 
  geom_histogram(mapping = aes(x = carat),binwidth=0.01) + 
  coord_cartesian(xlim = c(0,3))
```
The carat count below 1 with around 0.3 - 0.4 has the highest count since these sizes are typically used for diamond rings such as weddings and gifts. Moreover, 1 also have the 2nd highest count due to its perfect sizes for rings, necklaces, etc...


## Count plots

```{r}
ggplot(data = diamonds) +
  geom_count(mapping = aes(x = cut, y = clarity))

```
The count plots shows the relationship between the cut and clarity. It shows a large portion of diamonds in the ideal cut with VS2-VS1 clarity which is a perfect cut and clarity for consumer's sake.

## Scatter plots

```{r}
ggplot(data = diamonds) +
  geom_point(mapping = aes(x = x, y = y))

```
Zoom the scatter plot to see it clearer + add a line to confirm that the points are near y=x

```{r}
ggplot(data = diamonds) +
  geom_point(mapping = aes(x = x, y = y)) +
  coord_cartesian(xlim = c(3.5, 10), ylim = c(3.5,10))+
  geom_abline(slope = 1, intercept = 0, color = "red")
```
The x and y are approximately equal due to the proportions of diamonds being in most cases equal in the x and y axis. 


## One to one

```{r}
avg_price_by_carat <- diamonds %>%
  mutate(carat = round(carat, 1)) %>%
  group_by(carat) %>%
  summarise(avg_price = mean(price))

ggplot(data = avg_price_by_carat) +
  geom_line(mapping = aes(x = carat, y = avg_price))
```
The line plot shows the average prices vs carat. In the figure, it does makes sense as the carat gets higher (size gets bigger), the pricier it gets. This is due to the fact of the rarity and availability of high carat diamonds.


## Box Plot

```{r}
ggplot(data = diamonds) +
  geom_boxplot(mapping = aes(x = cut, y = price))

```
The box plot technically doesn't show the full picture as different variables does have some effect on the prices of diamonds. This include clarity and carat. It makes sense that there are outliers as shown in line plot, as the carats get larger the pricier it gets. So, the box plot doesn't show the whole picture but it is still unexpected to see the ideal cut to have a lower median than the rest of the cut despite being the best cut.


## Correlation Matrix

```{r}
corrmat <- cor(diamonds[, sapply(diamonds, is.numeric)], use = "complete.obs")
corrmat

ggcorrplot(corrmat, lab = TRUE, hc.order = TRUE)

```
This shows the correlation between the different aspects of diamonds, with 1 being the highest correlation

## Facet Grid

```{r}
ggplot(data = diamonds) +
  geom_point(mapping = aes(x = carat, y = price)) +
  facet_grid(clarity ~ cut)
```
Exercise at the end

```{r}
ggplot(data = diamonds) +
  geom_point(mapping = aes(x = carat, y = price, color = cut))


ggplot(diamonds, aes(x = cut, y = carat, fill = cut)) +
  geom_boxplot() +
  theme_minimal() +
  labs(title = "Distribution of Carat Size by Cut Quality",
       x = "Cut",
       y = "Carat",
       fill = "Cut") +
  scale_fill_brewer(palette = "Set2")
```
These graphs shows that as carat gets larger, the cut gets low (Fair & Good). This means that higher quality cuts are seen mostly on lower carat values. However, a positive note here is that as the carat increases, so does the price. The reason for the paradoxical trend is that larger diamonds are high in price due to its size and not entirely on cut. Moreover, a low carat but high quality cut can be more expensive than a larger carat but poor cut.



## Lecture 3

## Filtering

```{r}
# Filter to price greater than or equal to 10k
filter(diamonds, price >= 10000)
# filter with price of 10k or above and clarity of VVS1 and IF
filter(diamonds, price >= 10000 & clarity %in% c("VVS1", "IF"))

filter(diamonds, price >= 10000 & cut %in% c("Ideal") & carat >=3) 
```

There are 4 diamonds with a carat of atleast 3 with the price of greater than 10k and with an ideal cut.

## Select

```{r}

select(diamonds, carat, cut, color, clarity)
#Select Exercise
select(diamonds, -x,-y,-z)

```

## Arrange

```{r}
# arrange based on carat (ascending order)
arrange(diamonds, carat)
# arrange based on carat (descending order)
arrange(diamonds, desc(carat))
# arrange exercise
arrange(diamonds, desc(depth))

```
The lengthiest diamond would be with the depth of 79


## Mutate

```{r}
# Mutate (add another column - price per carat)
mutate(diamonds, price_per_carat = price/carat)
# mutate price per carat but is 10k or higher per carat
mutate(diamonds, fancy_diamond = price/carat > 10000)
# mutate with 2 cases
mutate(diamonds,
       good_value =
         if_else(
           condition = carat > 2, # check whether carat > 2
           true = price < 5000, # if so, good value if cheaper than $5k
           false = price < 1000 # if not, good value if cheaper than $1k
         )
)
```
Mutate Exercise

```{r}
# mutate exercise
diamonds %>%
  mutate(good_color = case_when(
    color %in% c("E", "D", "F", "G") ~ "TRUE",
    TRUE ~ "FALSE"
  ))
```

## Summarize

```{r}
summarise(diamonds, num_fancy_diamonds = sum(price/carat > 10000))
# summarise and their mean
summarise(diamonds,
          num_fancy_diamonds = sum(price/carat > 10000),
          mean_diamond_price = mean(price))
```

Summarise exercise

```{r}
summarise(diamonds,
          num_cheap_diamonds = sum(price/carat < 1000 & carat >=1))
```
There are no diamonds with the conditions.


## Pipe

```{r}
diamonds %>% 
  filter(cut == "Premium") %>% 
  mutate(price_per_carat = price/carat) %>% 
  ggplot() + 
  geom_histogram(aes(x = price_per_carat),binwidth=100)

```
Pipe exercise

```{r}
diamonds %>% 
  filter(carat >= 1) %>% 
  mutate(mean_price = mean(price))
```

## Group by

```{r}
diamonds %>% 
  group_by(cut, clarity) %>% 
  summarise(max_price = max(price)) %>% 
  ungroup()
```

Group by exercise

```{r}
# exercise, copy count with group by and summarise
diamonds %>% 
  group_by(cut) %>% 
  summarise(count = n()) %>% 
  ungroup()
```

## Storing Transformed Data

```{r}
max_prices <- diamonds %>% 
  group_by(cut) %>% 
  summarise(max_price = max(price))
max_prices
```

Exercise
```{r}
# 1. Minimum diamond price using two different dplyr verbs
diamonds %>% summarise(min_price = min(price))
diamonds %>% arrange(price) %>% slice(1) %>% select(price)

# 2. Number of diamonds with length at least 1.5 times their width
diamonds %>% filter(x >= 1.5 * y) %>% tally()

# 3. Median carats for diamonds of each cut among colors D, E, F, G
diamonds %>%
  filter(color %in% c("D", "E", "F", "G")) %>%
  group_by(cut) %>%
  summarise(median_carat = median(carat), .groups = "drop")
```

## Lecture 4

Use heights from tidyverse as the new dataset

```{r}
library(dslabs)
data(heights)
heights

table1
table2
table3
table4a
table4b
```

## Visualization

```{r}
ggplot(data = heights) +
  geom_count(mapping = aes(x = sex, y = height))

```

## Pivot Longer

```{r}
table4a %>%
  pivot_longer(cols = c(`1999`, `2000`), names_to = "year", values_to = "cases")

```

## Pivot Wide

```{r}
table2 %>%
  pivot_wider(names_from = type, values_from = count)
```

Note that Pivot Longer is the opposite of Pivot Wide, therefore the uses of each pivot are different depending on the scenario.

Exercise

```{r}
df<-tribble(
  ~pregnant, ~male, ~female,
  "yes", NA, 10,
  "no", 20, 12
)

df %>%
  pivot_longer(cols = c(male, female), names_to = "gender", values_to = "count")
```


## Join

```{r}
tidy4a <- table4a %>%
  pivot_longer(c(`1999`, `2000`), names_to = "year", values_to = "cases")
tidy4b <- table4b %>%
  pivot_longer(c(`1999`, `2000`), names_to = "year", values_to = "population")
tidy4a
tidy4b

left_join(x = tidy4a, y = tidy4b, by = c("country", "year"))
```

Exercise

```{r}
x <- tribble(
  ~state, ~population,
  "PA", 12.8,
  "TX", 28.6,
  "NY", 19.5
)
y <- tribble(
  ~state, ~capital,
  "TX", "Austin",
  "CA", "Sacramento",
  "NY", "New York City",
  "MI", "Lansing"
)

left_join(x,y)
left_join(y,x)
```

The number of rows differ depending on what table goes first. However with this situation, the columns did not change.

## Separate

```{r}
table3
table3 %>%
  separate(rate, into = c("cases", "population"),convert=TRUE)

table3 %>%
  separate(year, into = c("century", "year"), sep = 2)
```
## Missing values

```{r}
stocks <- tibble(
  year = c(2015, 2015, 2015, 2015, 2016, 2016, 2016),
  qtr = c( 1, 2, 3, 4, 2, 3, 4),
  return = c(1.88, 0.59, 0.35, NA, 0.92, 0.17, 2.66)
)
stocks
```
Use Pivot Wide to explicitly show hidden NA.

```{r}
stocks %>%
  pivot_wider(names_from = year, values_from = return)

```


Most common way to handle NA are to omit them from the table.

```{r}
stocks %>%
  na.omit()
```